<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>숨겨진 워터마크 찾기</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js" crossorigin="anonymous"></script>
    <style>
        :root {
            color-scheme: light dark;
        }
        body {
            margin: 0;
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: radial-gradient(circle at top, #1f1a2e, #090b13 55%, #07070a 100%);
            color: #f8f9ff;
            min-height: 100vh;
            padding: 40px 20px;
            box-sizing: border-box;
        }
        .container {
            max-width: 1260px;
            margin: 0 auto;
            background: rgba(17, 22, 34, 0.92);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 40px;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.45);
            border: 1px solid rgba(255, 0, 255, 0.2);
        }
        header {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 32px;
        }
        h1 {
            margin: 0;
            font-size: clamp(2.2rem, 3vw, 2.8rem);
            font-weight: 700;
            letter-spacing: -0.02em;
        }
        .subtitle {
            font-size: 1.05rem;
            line-height: 1.6;
            color: rgba(226, 231, 255, 0.85);
            max-width: 820px;
        }
        .chip-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 6px;
        }
        .chip {
            padding: 6px 14px;
            border-radius: 999px;
            font-size: 0.85rem;
            background: rgba(255, 0, 255, 0.16);
            border: 1px solid rgba(255, 0, 255, 0.24);
            letter-spacing: 0.01em;
            color: #ffb8ff;
        }
        .upload-zone, .reference-zone {
            border: 2px dashed rgba(255, 0, 255, 0.45);
            border-radius: 18px;
            padding: 36px;
            text-align: center;
            margin-bottom: 24px;
            transition: border 0.3s ease, background 0.3s ease, transform 0.3s ease;
            background: rgba(40, 24, 52, 0.4);
            cursor: pointer;
        }
        .reference-zone {
            border-style: dashed;
            border-color: rgba(97, 116, 255, 0.6);
            background: rgba(24, 36, 72, 0.4);
        }
        .upload-zone:hover,
        .upload-zone.dragover,
        .reference-zone:hover,
        .reference-zone.dragover {
            border-color: rgba(255, 153, 255, 0.95);
            background: rgba(60, 24, 72, 0.55);
            transform: translateY(-2px);
        }
        .reference-zone:hover,
        .reference-zone.dragover {
            border-color: rgba(130, 157, 255, 0.95);
            background: rgba(36, 48, 92, 0.55);
        }
        .upload-title {
            font-size: 1.3rem;
            margin-bottom: 10px;
            font-weight: 600;
        }
        .upload-hint {
            font-size: 0.95rem;
            color: rgba(226, 231, 255, 0.7);
        }
        .upload-actions {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 16px;
            flex-wrap: wrap;
        }
        .btn {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.85), rgba(130, 70, 255, 0.85));
            color: white;
            border: none;
            border-radius: 999px;
            padding: 11px 24px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.25s ease, box-shadow 0.25s ease;
            box-shadow: 0 12px 20px rgba(140, 60, 255, 0.35);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 16px 26px rgba(165, 60, 255, 0.45);
        }
        .btn.secondary {
            background: rgba(84, 95, 125, 0.22);
            border: 1px solid rgba(208, 216, 255, 0.25);
            box-shadow: none;
        }
        .btn.secondary:hover {
            background: rgba(108, 130, 172, 0.22);
            transform: none;
        }
        input[type="file"] {
            display: none;
        }
        .controls {
            background: rgba(19, 26, 43, 0.72);
            border-radius: 20px;
            padding: 24px 28px;
            border: 1px solid rgba(88, 98, 134, 0.4);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 22px 28px;
            margin-bottom: 32px;
        }
        .control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .control label {
            font-size: 0.9rem;
            color: rgba(226, 231, 255, 0.75);
            font-weight: 600;
            letter-spacing: 0.01em;
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .control input[type="range"] {
            flex: 1;
        }
        .value-tag {
            min-width: 58px;
            padding: 6px 12px;
            background: rgba(255, 0, 255, 0.14);
            border-radius: 999px;
            border: 1px solid rgba(255, 0, 255, 0.22);
            color: #ffc8ff;
            font-size: 0.8rem;
            text-align: center;
            letter-spacing: 0.02em;
        }
        .canvas-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 24px;
        }
        .canvas-card {
            background: rgba(17, 22, 34, 0.65);
            border-radius: 18px;
            padding: 18px;
            border: 1px solid rgba(92, 108, 150, 0.35);
            display: flex;
            flex-direction: column;
            gap: 16px;
            backdrop-filter: blur(18px);
        }
        .canvas-title {
            font-weight: 600;
            font-size: 1rem;
            letter-spacing: 0.01em;
        }
        canvas {
            width: 100%;
            height: auto;
            border-radius: 12px;
            background: rgba(4, 5, 9, 0.9);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
        }
        .info-panel {
            background: rgba(17, 22, 34, 0.78);
            border-radius: 18px;
            padding: 24px 26px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            border: 1px solid rgba(99, 106, 138, 0.4);
        }
        .info-panel h2 {
            margin: 0;
            font-size: 1.05rem;
            font-weight: 600;
        }
        .info-panel p {
            margin: 0;
            font-size: 0.95rem;
            line-height: 1.6;
            color: rgba(226, 231, 255, 0.7);
        }
        .info-panel ul {
            margin: 0;
            padding-left: 18px;
            color: rgba(226, 231, 255, 0.7);
            line-height: 1.6;
            font-size: 0.92rem;
        }
        .info-actions {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
        }
        .ocr-results {
            background: rgba(34, 36, 58, 0.65);
            border-radius: 14px;
            border: 1px solid rgba(130, 140, 190, 0.32);
            padding: 14px 16px;
            font-size: 0.92rem;
            line-height: 1.5;
            color: rgba(231, 235, 255, 0.9);
        }
        .ocr-results strong {
            color: #ffb8ff;
        }
        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 0.78rem;
            background: rgba(255, 0, 255, 0.18);
            border: 1px solid rgba(255, 0, 255, 0.25);
            color: #ffd8ff;
            margin-right: 6px;
        }
        @media (max-width: 1024px) {
            .container {
                padding: 28px;
            }
            .controls {
                padding: 20px;
            }
            .canvas-grid {
                grid-template-columns: 1fr;
            }
        }
        @media (max-width: 640px) {
            body {
                padding: 20px 14px;
            }
            .container {
                padding: 22px 18px;
            }
            .upload-zone,
            .reference-zone {
                padding: 26px 18px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>숨겨진 워터마크 탐지기</h1>
            <p class="subtitle">
                0.1 투명도로 숨겨진 보라색 워터마크(<code>rgba(255, 0, 255, 0.1)</code>)를 색상/채도/참고 이미지 차이를 이용해 정밀하게 탐지하고,
                추출된 영역에서 <strong>닉네임 · 시간</strong> 텍스트를 자동 인식합니다.
            </p>
            <div class="chip-row">
                <span class="chip">Step 1 · 원본 이미지 업로드</span>
                <span class="chip">Step 2 · (선택) 워터마크 강조본 추가</span>
                <span class="chip">Step 3 · 슬라이더로 감도 보정 &amp; OCR 실행</span>
            </div>
        </header>

        <div id="dropZone" class="upload-zone" role="button" aria-label="원본 이미지 업로드">
            <div class="upload-title">① 원본 이미지 올리기</div>
            <div class="upload-hint">JPG / PNG / WEBP 지원 · 워터마크가 숨겨진 첫 번째 이미지를 선택하세요.</div>
            <div class="upload-actions">
                <button class="btn" id="browseButton">파일 선택</button>
                <button class="btn secondary" id="sampleButton">체험용 이미지 사용</button>
            </div>
            <div id="fileInfo" class="upload-hint" style="margin-top: 14px; display: none;"></div>
        </div>
        <input type="file" id="fileInput" accept="image/*">

        <div id="referenceZone" class="reference-zone" role="button" aria-label="보정된 참고 이미지 업로드">
            <div class="upload-title">② 참고용 강조 이미지 추가 (선택)</div>
            <div class="upload-hint">
                두 번째 이미지를 올려 색감/밝기 차이로 워터마크 점수를 보강합니다. 원본과 같은 해상도일수록 정확도가 올라갑니다.
            </div>
            <div class="upload-actions">
                <button class="btn secondary" id="referenceButton">참고 이미지 선택</button>
                <button class="btn secondary" id="clearReference" type="button">추가 이미지 제거</button>
            </div>
            <div id="referenceInfo" class="upload-hint" style="margin-top: 14px; display: none;"></div>
        </div>
        <input type="file" id="referenceInput" accept="image/*">

        <section class="controls" aria-label="워터마크 감지 조절">
            <div class="control">
                <label for="sensitivity">민감도(워터마크 색 강화)</label>
                <div class="control-row">
                    <input type="range" id="sensitivity" min="1" max="12" step="0.1" value="4.5">
                    <span class="value-tag" id="sensitivityValue">4.5×</span>
                </div>
            </div>
            <div class="control">
                <label for="threshold">임곗값(워터마크 판단 기준)</label>
                <div class="control-row">
                    <input type="range" id="threshold" min="5" max="90" step="1" value="34">
                    <span class="value-tag" id="thresholdValue">34%</span>
                </div>
            </div>
            <div class="control">
                <label for="gamma">강조 감마(퍼짐 보정)</label>
                <div class="control-row">
                    <input type="range" id="gamma" min="40" max="160" step="1" value="70">
                    <span class="value-tag" id="gammaValue">0.70</span>
                </div>
            </div>
            <div class="control">
                <label for="balance">Green 억제량 (배경 제거)</label>
                <div class="control-row">
                    <input type="range" id="balance" min="40" max="160" step="1" value="95">
                    <span class="value-tag" id="balanceValue">0.95×</span>
                </div>
            </div>
            <div class="control">
                <label for="overlay">강조 오버레이 투명도</label>
                <div class="control-row">
                    <input type="range" id="overlay" min="10" max="100" step="1" value="65">
                    <span class="value-tag" id="overlayValue">65%</span>
                </div>
            </div>
            <div class="control">
                <label for="hueWeight">마젠타 색상 가중치</label>
                <div class="control-row">
                    <input type="range" id="hueWeight" min="40" max="160" step="1" value="110">
                    <span class="value-tag" id="hueWeightValue">1.10×</span>
                </div>
            </div>
        </section>

        <section class="canvas-grid">
            <article class="canvas-card">
                <div class="canvas-title">원본 이미지</div>
                <canvas id="originalCanvas" width="0" height="0" aria-label="업로드한 원본"></canvas>
            </article>
            <article class="canvas-card">
                <div class="canvas-title">워터마크 강조 뷰</div>
                <canvas id="analysisCanvas" width="0" height="0" aria-label="워터마크 강조 결과"></canvas>
            </article>
        </section>

        <section class="info-panel">
            <h2>감지 결과</h2>
            <p id="highlightInfo">아직 업로드된 이미지가 없습니다. 원본 이미지를 올리면 워터마크 후보 영역/픽셀 수와 OCR 결과가 표시됩니다.</p>
            <ul>
                <li>임곗값을 낮추면 더 많은 픽셀이 후보에 포함되고, 높이면 확실한 영역만 남습니다.</li>
                <li>참고 이미지를 추가하면 두 이미지 간 마젠타 변화량을 반영해서 박스 정밀도가 향상됩니다.</li>
                <li>워터마크가 반복되는 경우 가장 큰 영역부터 최대 3곳까지 텍스트를 인식합니다.</li>
            </ul>
            <div id="ocrResults" class="ocr-results" hidden></div>
            <div class="info-actions">
                <button class="btn" id="downloadButton">강조 캡처 저장</button>
                <button class="btn secondary" id="resetButton">초기화</button>
            </div>
        </section>
    </div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const referenceInput = document.getElementById('referenceInput');
        const browseButton = document.getElementById('browseButton');
        const sampleButton = document.getElementById('sampleButton');
        const referenceButton = document.getElementById('referenceButton');
        const clearReferenceButton = document.getElementById('clearReference');
        const dropZone = document.getElementById('dropZone');
        const referenceZone = document.getElementById('referenceZone');
        const fileInfo = document.getElementById('fileInfo');
        const referenceInfo = document.getElementById('referenceInfo');

        const originalCanvas = document.getElementById('originalCanvas');
        const analysisCanvas = document.getElementById('analysisCanvas');
        const originalCtx = originalCanvas.getContext('2d');
        const analysisCtx = analysisCanvas.getContext('2d');
        const heatmapCanvas = document.createElement('canvas');
        const heatmapCtx = heatmapCanvas.getContext('2d');
        const referenceCanvas = document.createElement('canvas');
        const referenceCtx = referenceCanvas.getContext('2d');
        const ocrResultsBox = document.getElementById('ocrResults');

        const controls = {
            sensitivity: document.getElementById('sensitivity'),
            threshold: document.getElementById('threshold'),
            gamma: document.getElementById('gamma'),
            balance: document.getElementById('balance'),
            overlay: document.getElementById('overlay'),
            hueWeight: document.getElementById('hueWeight')
        };

        const displayTags = {
            sensitivity: document.getElementById('sensitivityValue'),
            threshold: document.getElementById('thresholdValue'),
            gamma: document.getElementById('gammaValue'),
            balance: document.getElementById('balanceValue'),
            overlay: document.getElementById('overlayValue'),
            hueWeight: document.getElementById('hueWeightValue')
        };

        const highlightInfo = document.getElementById('highlightInfo');
        const downloadButton = document.getElementById('downloadButton');
        const resetButton = document.getElementById('resetButton');

        const state = {
            imageData: null,
            referenceData: null,
            scoreBuffer: null,
            bufferWidth: 0,
            bufferHeight: 0,
            lastFileName: null,
            lastReferenceName: null,
            hotZones: [],
            ocrJobId: 0
        };

        let ocrDebounceHandle = null;

        browseButton.addEventListener('click', () => fileInput.click());
        referenceButton.addEventListener('click', () => referenceInput.click());

        sampleButton.addEventListener('click', async () => {
            try {
                const response = await fetch('https://images.pexels.com/photos/415829/pexels-photo-415829.jpeg?auto=compress&cs=tinysrgb&w=1200');
                const blob = await response.blob();
                const file = new File([blob], 'sample.jpg', { type: blob.type });
                handlePrimaryFile(file);
            } catch (error) {
                alert('체험용 이미지를 불러오지 못했습니다. 네트워크 연결을 확인하거나 직접 이미지를 올려주세요.');
            }
        });

        fileInput.addEventListener('change', (event) => {
            if (event.target.files && event.target.files[0]) {
                handlePrimaryFile(event.target.files[0]);
            }
        });

        referenceInput.addEventListener('change', (event) => {
            if (event.target.files && event.target.files[0]) {
                handleReferenceFile(event.target.files[0]);
            }
        });

        clearReferenceButton.addEventListener('click', () => {
            state.referenceData = null;
            state.lastReferenceName = null;
            referenceInfo.style.display = 'none';
            referenceInput.value = '';
            updateAnalysis();
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropZone.classList.add('dragover');
            });
        });
        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropZone.classList.remove('dragover');
            });
        });
        dropZone.addEventListener('drop', (event) => {
            const file = event.dataTransfer.files && event.dataTransfer.files[0];
            if (file) {
                handlePrimaryFile(file);
            }
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            referenceZone.addEventListener(eventName, (event) => {
                event.preventDefault();
                event.stopPropagation();
                referenceZone.classList.add('dragover');
            });
        });
        ['dragleave', 'drop'].forEach(eventName => {
            referenceZone.addEventListener(eventName, (event) => {
                event.preventDefault();
                event.stopPropagation();
                referenceZone.classList.remove('dragover');
            });
        });
        referenceZone.addEventListener('drop', (event) => {
            const file = event.dataTransfer.files && event.dataTransfer.files[0];
            if (file) {
                handleReferenceFile(file);
            }
        });

        Object.entries(controls).forEach(([key, input]) => {
            input.addEventListener('input', () => {
                updateDisplayTag(key, input.value);
                updateAnalysisDebounced();
            });
        });

        downloadButton.addEventListener('click', () => {
            if (!state.imageData) {
                alert('먼저 이미지를 업로드해 주세요.');
                return;
            }
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.href = analysisCanvas.toDataURL('image/png');
            link.download = `watermark-highlight-${timestamp}.png`;
            link.click();
        });

        resetButton.addEventListener('click', () => {
            Object.assign(state, {
                imageData: null,
                referenceData: null,
                scoreBuffer: null,
                bufferWidth: 0,
                bufferHeight: 0,
                lastFileName: null,
                lastReferenceName: null,
                hotZones: [],
                ocrJobId: state.ocrJobId + 1
            });
            originalCanvas.width = analysisCanvas.width = 0;
            originalCanvas.height = analysisCanvas.height = 0;
            heatmapCanvas.width = heatmapCanvas.height = 0;
            referenceCanvas.width = referenceCanvas.height = 0;
            highlightInfo.textContent = '초기화되었습니다. 다시 이미지를 업로드해 주세요.';
            fileInfo.style.display = 'none';
            referenceInfo.style.display = 'none';
            ocrResultsBox.hidden = true;
            ocrResultsBox.innerHTML = '';
            fileInput.value = '';
            referenceInput.value = '';
        });

        function updateDisplayTag(key, value) {
            switch (key) {
                case 'sensitivity':
                    displayTags[key].textContent = parseFloat(value).toFixed(1) + '\u00d7';
                    break;
                case 'threshold':
                    displayTags[key].textContent = value + '%';
                    break;
                case 'gamma':
                    displayTags[key].textContent = (value / 100).toFixed(2);
                    break;
                case 'balance':
                    displayTags[key].textContent = (value / 100).toFixed(2) + '\u00d7';
                    break;
                case 'overlay':
                    displayTags[key].textContent = value + '%';
                    break;
                case 'hueWeight':
                    displayTags[key].textContent = (value / 100).toFixed(2) + '\u00d7';
                    break;
                default:
                    displayTags[key].textContent = value;
            }
        }

        function updateAnalysisDebounced() {
            if (!state.imageData) return;
            if (ocrDebounceHandle) {
                cancelAnimationFrame(ocrDebounceHandle);
            }
            ocrDebounceHandle = requestAnimationFrame(() => {
                updateAnalysis();
            });
        }

        function handlePrimaryFile(file) {
            if (!file || !file.type.startsWith('image/')) {
                alert('이미지 파일만 업로드할 수 있습니다.');
                return;
            }
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    renderPrimaryImage(img);
                    state.lastFileName = file.name;
                    fileInfo.style.display = 'block';
                    fileInfo.textContent = `불러온 파일: ${file.name} · ${Math.round(file.size / 1024)} KB (${img.naturalWidth}\u00d7${img.naturalHeight})`;
                };
                img.onerror = () => alert('이미지를 불러오는 중 문제가 발생했습니다. 다시 시도해 주세요.');
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function handleReferenceFile(file) {
            if (!state.imageData) {
                alert('먼저 원본 이미지를 업로드해 주세요.');
                referenceInput.value = '';
                return;
            }
            if (!file || !file.type.startsWith('image/')) {
                alert('이미지 파일만 업로드할 수 있습니다.');
                return;
            }
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    renderReferenceImage(img);
                    state.lastReferenceName = file.name;
                    referenceInfo.style.display = 'block';
                    referenceInfo.textContent = `참고 이미지: ${file.name} (${img.naturalWidth}\u00d7${img.naturalHeight})가 적용되었습니다.`;
                };
                img.onerror = () => alert('참고 이미지를 불러오는 중 문제가 발생했습니다. 다시 시도해 주세요.');
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function renderPrimaryImage(img) {
            const maxDimension = 2400;
            let { width, height } = img;
            if (width > maxDimension || height > maxDimension) {
                const scale = maxDimension / Math.max(width, height);
                width = Math.round(width * scale);
                height = Math.round(height * scale);
            }
            originalCanvas.width = width;
            originalCanvas.height = height;
            analysisCanvas.width = width;
            analysisCanvas.height = height;
            heatmapCanvas.width = width;
            heatmapCanvas.height = height;

            originalCtx.clearRect(0, 0, width, height);
            originalCtx.drawImage(img, 0, 0, width, height);
            state.imageData = originalCtx.getImageData(0, 0, width, height);
            state.bufferWidth = width;
            state.bufferHeight = height;
            state.scoreBuffer = new Float32Array(width * height);

            if (state.referenceData) {
                renderReferenceImageFromData();
            }
            updateAnalysis();
        }

        function renderReferenceImage(img) {
            if (!state.imageData) return;
            const { bufferWidth: width, bufferHeight: height } = state;
            referenceCanvas.width = width;
            referenceCanvas.height = height;
            referenceCtx.clearRect(0, 0, width, height);
            referenceCtx.drawImage(img, 0, 0, width, height);
            state.referenceData = referenceCtx.getImageData(0, 0, width, height);
            updateAnalysis();
        }

        function renderReferenceImageFromData() {
            if (!state.referenceData) return;
            const { bufferWidth: width, bufferHeight: height } = state;
            referenceCanvas.width = width;
            referenceCanvas.height = height;
            referenceCtx.putImageData(state.referenceData, 0, 0);
        }

        function updateAnalysis() {
            if (!state.imageData) {
                return;
            }
            const width = originalCanvas.width;
            const height = originalCanvas.height;
            const data = state.imageData.data;
            const refData = state.referenceData ? state.referenceData.data : null;
            const heatmapData = heatmapCtx.createImageData(width, height);
            const heatmapPixels = heatmapData.data;
            const scoreBuffer = state.scoreBuffer || new Float32Array(width * height);

            const sensitivity = parseFloat(controls.sensitivity.value);
            const threshold = parseFloat(controls.threshold.value) / 100;
            const gamma = parseFloat(controls.gamma.value) / 100;
            const balance = parseFloat(controls.balance.value) / 100;
            const overlay = parseFloat(controls.overlay.value) / 100;
            const hueWeight = parseFloat(controls.hueWeight.value) / 100;

            const tileSize = Math.max(16, Math.round(Math.min(width, height) / 90));
            const tilesX = Math.ceil(width / tileSize);
            const tilesY = Math.ceil(height / tileSize);
            const tileScores = new Float32Array(tilesX * tilesY);
            const tileCounts = new Uint32Array(tilesX * tilesY);

            let hotPixels = 0;
            let strongestScore = 0;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];
                    const alpha = data[index + 3] / 255;

                    const magentaBase = Math.max(0, ((r + b) * 0.5) - (g * balance));
                    const rbCloseness = 1 - Math.min(Math.abs(r - b) / 255, 1);

                    const maxChannel = Math.max(r, g, b) / 255;
                    const minChannel = Math.min(r, g, b) / 255;
                    const delta = maxChannel - minChannel;
                    let hue = 0;
                    let saturation = 0;
                    if (delta > 0.0001) {
                        saturation = maxChannel === 0 ? 0 : delta / maxChannel;
                        if (maxChannel === r / 255) {
                            hue = ((g - b) / (255 * delta)) % 6;
                        } else if (maxChannel === g / 255) {
                            hue = (b - r) / (255 * delta) + 2;
                        } else {
                            hue = (r - g) / (255 * delta) + 4;
                        }
                        hue *= 60;
                        if (hue < 0) hue += 360;
                    }
                    const hueDistance = Math.min(
                        Math.abs(hue - 300),
                        Math.abs((hue + 360) - 300),
                        Math.abs((hue - 360) - 300)
                    );
                    const hueConfidence = Math.max(0, 1 - (hueDistance / 80));
                    const saturationBoost = Math.max(0, saturation - 0.25);

                    let score = (magentaBase / 255) * (0.65 + rbCloseness * 0.35);
                    score *= (0.55 + hueConfidence * hueWeight);
                    score *= (0.6 + saturationBoost * 1.2);
                    score *= Math.max(0.5, alpha);
                    score *= sensitivity;

                    if (refData) {
                        const refMagenta = Math.max(0, ((refData[index] + refData[index + 2]) * 0.5) - refData[index + 1]);
                        const referenceBoost = Math.max(0, (refMagenta - magentaBase) / 255);
                        score += referenceBoost * 1.1;
                    }

                    if (score > 0) {
                        score = Math.pow(score, gamma);
                    }
                    score = Math.min(1, score);

                    scoreBuffer[(y * width) + x] = score;

                    const heatColor = heatToRgb(score);
                    const pixelAlpha = Math.round(Math.min(1, score * 1.15) * 255);

                    heatmapPixels[index] = heatColor.r;
                    heatmapPixels[index + 1] = heatColor.g;
                    heatmapPixels[index + 2] = heatColor.b;
                    heatmapPixels[index + 3] = pixelAlpha;

                    if (score >= threshold) {
                        hotPixels++;
                    }

                    if (score > strongestScore) {
                        strongestScore = score;
                    }

                    const tileIndex = (Math.floor(y / tileSize) * tilesX) + Math.floor(x / tileSize);
                    tileScores[tileIndex] += score;
                    tileCounts[tileIndex]++;
                }
            }

            state.scoreBuffer = scoreBuffer;

            heatmapCtx.putImageData(heatmapData, 0, 0);
            analysisCtx.clearRect(0, 0, width, height);
            analysisCtx.drawImage(originalCanvas, 0, 0);
            analysisCtx.globalAlpha = overlay;
            analysisCtx.drawImage(heatmapCanvas, 0, 0);
            analysisCtx.globalAlpha = 1;

            const tileMask = new Uint8Array(tileScores.length);
            for (let i = 0; i < tileScores.length; i++) {
                if (!tileCounts[i]) continue;
                const avg = tileScores[i] / tileCounts[i];
                if (avg >= threshold * 0.85) {
                    tileMask[i] = 1;
                }
            }

            const zones = buildZonesFromTiles(tileMask, tilesX, tilesY, tileSize, width, height, threshold);
            state.hotZones = zones;

            drawZones(zones);

            const pixelPercent = hotPixels ? (hotPixels / (width * height)) * 100 : 0;
            const zoneSummary = zones.length
                ? `${zones.length}개 영역에서 워터마크 후보 감지 (가중 픽셀 ${hotPixels.toLocaleString()}개 · ${pixelPercent.toFixed(3)}%)`
                : '현재 설정에서는 확실한 워터마크 영역이 잡히지 않습니다. 감도/임곗값을 조절해 주세요.';
            const referenceBadge = state.referenceData ? '<span class="badge">참고 이미지 보강 적용</span>' : '';
            highlightInfo.innerHTML = `${referenceBadge}${zoneSummary}`;

            scheduleOcr(zones, threshold);
        }

        function buildZonesFromTiles(tileMask, tilesX, tilesY, tileSize, width, height, threshold) {
            const visited = new Uint8Array(tileMask.length);
            const zones = [];
            const stack = [];
            const neighbors = [1, -1, tilesX, -tilesX];

            for (let i = 0; i < tileMask.length; i++) {
                if (!tileMask[i] || visited[i]) continue;
                let minTileX = tilesX;
                let minTileY = tilesY;
                let maxTileX = -1;
                let maxTileY = -1;
                let cumulativeScore = 0;
                let cumulativeCount = 0;

                stack.push(i);
                visited[i] = 1;

                while (stack.length) {
                    const current = stack.pop();
                    const tileY = Math.floor(current / tilesX);
                    const tileX = current - tileY * tilesX;
                    if (tileX < minTileX) minTileX = tileX;
                    if (tileY < minTileY) minTileY = tileY;
                    if (tileX > maxTileX) maxTileX = tileX;
                    if (tileY > maxTileY) maxTileY = tileY;
                    cumulativeCount++;

                    neighbors.forEach(offset => {
                        const next = current + offset;
                        if (next < 0 || next >= tileMask.length) return;
                        if (tileMask[next] && !visited[next]) {
                            const nextY = Math.floor(next / tilesX);
                            const nextX = next - nextY * tilesX;
                            if (Math.abs(nextX - tileX) + Math.abs(nextY - tileY) === 1) {
                                visited[next] = 1;
                                stack.push(next);
                            }
                        }
                    });
                }

                const pixelX = Math.max(0, minTileX * tileSize - Math.round(tileSize * 0.35));
                const pixelY = Math.max(0, minTileY * tileSize - Math.round(tileSize * 0.35));
                const pixelWidth = Math.min(width - pixelX, (maxTileX - minTileX + 1) * tileSize + Math.round(tileSize * 0.7));
                const pixelHeight = Math.min(height - pixelY, (maxTileY - minTileY + 1) * tileSize + Math.round(tileSize * 0.7));

                if (pixelWidth * pixelHeight < 6000) {
                    continue; // 노이즈 제거
                }

                cumulativeScore = summarizeZoneScore(pixelX, pixelY, pixelWidth, pixelHeight, threshold);

                const zone = {
                    x: pixelX,
                    y: pixelY,
                    width: pixelWidth,
                    height: pixelHeight,
                    area: pixelWidth * pixelHeight,
                    score: cumulativeScore
                };
                zones.push(zone);
            }

            zones.sort((a, b) => b.score - a.score);
            return zones.slice(0, 6);
        }

        function summarizeZoneScore(x, y, width, height, threshold) {
            const buffer = state.scoreBuffer;
            const canvasWidth = state.bufferWidth;
            let sum = 0;
            let strongCount = 0;
            for (let yy = y; yy < y + height; yy++) {
                const rowOffset = yy * canvasWidth;
                for (let xx = x; xx < x + width; xx++) {
                    const score = buffer[rowOffset + xx];
                    sum += score;
                    if (score >= threshold) strongCount++;
                }
            }
            return sum + strongCount * 0.3;
        }

        function drawZones(zones) {
            const ctx = analysisCtx;
            zones.forEach((zone, index) => {
                ctx.save();
                ctx.shadowColor = 'rgba(255, 55, 220, 0.55)';
                ctx.shadowBlur = Math.max(10, Math.round(Math.min(analysisCanvas.width, analysisCanvas.height) * 0.015));
                ctx.lineWidth = Math.max(2, Math.round(Math.min(analysisCanvas.width, analysisCanvas.height) * 0.004));
                ctx.strokeStyle = 'rgba(255, 55, 220, 0.95)';
                ctx.strokeRect(zone.x, zone.y, zone.width, zone.height);
                ctx.restore();

                ctx.save();
                ctx.fillStyle = 'rgba(16, 6, 24, 0.78)';
                ctx.font = '600 16px "Pretendard", sans-serif';
                ctx.textBaseline = 'top';
                const label = `Zone ${index + 1}`;
                const labelWidth = ctx.measureText(label).width + 12;
                const labelHeight = 22;
                const labelX = Math.max(zone.x, 6);
                const labelY = Math.max(zone.y - labelHeight - 4, 6);
                ctx.fillRect(labelX - 6, labelY - 2, labelWidth, labelHeight);
                ctx.fillStyle = '#ffb8ff';
                ctx.fillText(label, labelX, labelY);
                ctx.restore();
            });
        }

        function scheduleOcr(zones, threshold) {
            if (!zones.length) {
                ocrResultsBox.hidden = true;
                ocrResultsBox.innerHTML = '';
                state.ocrJobId++;
                return;
            }
            const jobId = ++state.ocrJobId;
            ocrResultsBox.hidden = false;
            ocrResultsBox.innerHTML = '워터마크 텍스트 분석 중... (슬라이더 조정 시 자동 갱신)';

            const ocrDelay = new Promise(resolve => setTimeout(resolve, 150));
            ocrDelay.then(async () => {
                if (jobId !== state.ocrJobId) return;
                await runOcrOnZones(zones, threshold, jobId);
            });
        }

        async function runOcrOnZones(zones, threshold, jobId) {
            if (typeof Tesseract === 'undefined') {
                ocrResultsBox.innerHTML = 'Tesseract.js가 아직 로드되지 않았습니다. 잠시 후 다시 시도해 주세요.';
                return;
            }
            const ocrTargets = zones.slice(0, 3);
            const results = [];

            for (let i = 0; i < ocrTargets.length; i++) {
                if (jobId !== state.ocrJobId) {
                    return;
                }
                const zone = ocrTargets[i];
                const ocrCanvas = buildOcrCanvas(zone, threshold);
                try {
                    const { data: { text } } = await Tesseract.recognize(ocrCanvas, 'eng', {
                        logger: () => {}
                    });
                    const cleaned = cleanOcrText(text);
                    if (cleaned) {
                        results.push({ zoneIndex: i + 1, text: cleaned, parsed: parseWatermark(cleaned) });
                    }
                } catch (error) {
                    console.error('OCR 오류', error);
                }
            }

            if (jobId !== state.ocrJobId) {
                return;
            }

            if (!results.length) {
                ocrResultsBox.innerHTML = 'OCR 결과를 읽지 못했습니다. 임곗값을 낮추거나 참고 이미지를 추가해 보세요.';
                return;
            }

            ocrResultsBox.innerHTML = results.map(result => {
                const lines = [`<strong>Zone ${result.zoneIndex}</strong> : ${result.text}`];
                if (result.parsed.nickname || result.parsed.timestamp) {
                    lines.push('<br>↳ 추출값 - ' + [
                        result.parsed.nickname ? `닉네임: <strong>${result.parsed.nickname}</strong>` : null,
                        result.parsed.timestamp ? `시간: <strong>${result.parsed.timestamp}</strong>` : null
                    ].filter(Boolean).join(' · '));
                }
                return lines.join('');
            }).join('<hr style="border: 0; border-top: 1px solid rgba(255, 255, 255, 0.12); margin: 12px 0;">');
        }

        function buildOcrCanvas(zone, threshold) {
            const { x, y, width, height } = zone;
            const buffer = state.scoreBuffer;
            const canvasWidth = state.bufferWidth;
            const ocrCanvas = document.createElement('canvas');
            ocrCanvas.width = width;
            ocrCanvas.height = height;
            const ctx = ocrCanvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);
            const pixels = imageData.data;

            for (let yy = 0; yy < height; yy++) {
                const srcRow = (y + yy) * canvasWidth;
                const dstRow = yy * width;
                for (let xx = 0; xx < width; xx++) {
                    const score = buffer[srcRow + x + xx];
                    const boosted = score >= threshold ? 255 : Math.min(255, Math.pow(score, 0.8) * 255);
                    const idx = (dstRow + xx) * 4;
                    pixels[idx] = boosted;
                    pixels[idx + 1] = boosted;
                    pixels[idx + 2] = boosted;
                    pixels[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            return ocrCanvas;
        }

        function cleanOcrText(text) {
            if (!text) return '';
            const normalized = text.replace(/\s+/g, ' ').replace(/[|]+/g, ' | ').trim();
            return normalized.length > 3 ? normalized : '';
        }

        function parseWatermark(text) {
            const result = { nickname: null, timestamp: null };
            const nicknameMatch = text.match(/(?:User|ID|Nick)\s*[:|-]\s*([A-Za-z0-9_\-\.]+)/i);
            if (nicknameMatch) {
                result.nickname = nicknameMatch[1];
            }
            const timeMatch = text.match(/(?:Date|Time|Shot)\s*[:|-]\s*([0-9]{4}[\/-][0-9]{2}[\/-][0-9]{2}[ T][0-9]{2}:[0-9]{2}:[0-9]{2})/i);
            if (timeMatch) {
                result.timestamp = timeMatch[1].replace(/[T]/, ' ');
            }
            return result;
        }

        function heatToRgb(value) {
            const clamped = Math.max(0, Math.min(1, value));
            const hue = (1 - clamped) * 240 / 360;
            const { r, g, b } = hslToRgb(hue, 1, 0.5);
            return { r, g, b };
        }

        function hslToRgb(h, s, l) {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }

        Object.entries(controls).forEach(([key, input]) => updateDisplayTag(key, input.value));
    </script>
</body>
</html>
